{"version":3,"sources":["Chart.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Chart.min.js","sourcesContent":["/*!\n * Chart.js\n * http://chartjs.org/\n *\n * Copyright 2013 Nick Downie\n * Released under the MIT license\n * https://github.com/nnnick/Chart.js/blob/master/LICENSE.md\n */\n\n//Define the global Chart Variable as a class.\nwindow.Chart = function(context){\n\n\tvar chart = this;\n\t\n\t\n\t//Easing functions adapted from Robert Penner's easing equations\n\t//http://www.robertpenner.com/easing/\n\t\n\tvar animationOptions = {\n\t\tlinear : function (t){\n\t\t\treturn t;\n\t\t},\n\t\teaseInQuad: function (t) {\n\t\t\treturn t*t;\n\t\t},\n\t\teaseOutQuad: function (t) {\n\t\t\treturn -1 *t*(t-2);\n\t\t},\n\t\teaseInOutQuad: function (t) {\n\t\t\tif ((t/=1/2) < 1) return 1/2*t*t;\n\t\t\treturn -1/2 * ((--t)*(t-2) - 1);\n\t\t},\n\t\teaseInCubic: function (t) {\n\t\t\treturn t*t*t;\n\t\t},\n\t\teaseOutCubic: function (t) {\n\t\t\treturn 1*((t=t/1-1)*t*t + 1);\n\t\t},\n\t\teaseInOutCubic: function (t) {\n\t\t\tif ((t/=1/2) < 1) return 1/2*t*t*t;\n\t\t\treturn 1/2*((t-=2)*t*t + 2);\n\t\t},\n\t\teaseInQuart: function (t) {\n\t\t\treturn t*t*t*t;\n\t\t},\n\t\teaseOutQuart: function (t) {\n\t\t\treturn -1 * ((t=t/1-1)*t*t*t - 1);\n\t\t},\n\t\teaseInOutQuart: function (t) {\n\t\t\tif ((t/=1/2) < 1) return 1/2*t*t*t*t;\n\t\t\treturn -1/2 * ((t-=2)*t*t*t - 2);\n\t\t},\n\t\teaseInQuint: function (t) {\n\t\t\treturn 1*(t/=1)*t*t*t*t;\n\t\t},\n\t\teaseOutQuint: function (t) {\n\t\t\treturn 1*((t=t/1-1)*t*t*t*t + 1);\n\t\t},\n\t\teaseInOutQuint: function (t) {\n\t\t\tif ((t/=1/2) < 1) return 1/2*t*t*t*t*t;\n\t\t\treturn 1/2*((t-=2)*t*t*t*t + 2);\n\t\t},\n\t\teaseInSine: function (t) {\n\t\t\treturn -1 * Math.cos(t/1 * (Math.PI/2)) + 1;\n\t\t},\n\t\teaseOutSine: function (t) {\n\t\t\treturn 1 * Math.sin(t/1 * (Math.PI/2));\n\t\t},\n\t\teaseInOutSine: function (t) {\n\t\t\treturn -1/2 * (Math.cos(Math.PI*t/1) - 1);\n\t\t},\n\t\teaseInExpo: function (t) {\n\t\t\treturn (t==0) ? 1 : 1 * Math.pow(2, 10 * (t/1 - 1));\n\t\t},\n\t\teaseOutExpo: function (t) {\n\t\t\treturn (t==1) ? 1 : 1 * (-Math.pow(2, -10 * t/1) + 1);\n\t\t},\n\t\teaseInOutExpo: function (t) {\n\t\t\tif (t==0) return 0;\n\t\t\tif (t==1) return 1;\n\t\t\tif ((t/=1/2) < 1) return 1/2 * Math.pow(2, 10 * (t - 1));\n\t\t\treturn 1/2 * (-Math.pow(2, -10 * --t) + 2);\n\t\t\t},\n\t\teaseInCirc: function (t) {\n\t\t\tif (t>=1) return t;\n\t\t\treturn -1 * (Math.sqrt(1 - (t/=1)*t) - 1);\n\t\t},\n\t\teaseOutCirc: function (t) {\n\t\t\treturn 1 * Math.sqrt(1 - (t=t/1-1)*t);\n\t\t},\n\t\teaseInOutCirc: function (t) {\n\t\t\tif ((t/=1/2) < 1) return -1/2 * (Math.sqrt(1 - t*t) - 1);\n\t\t\treturn 1/2 * (Math.sqrt(1 - (t-=2)*t) + 1);\n\t\t},\n\t\teaseInElastic: function (t) {\n\t\t\tvar s=1.70158;var p=0;var a=1;\n\t\t\tif (t==0) return 0;  if ((t/=1)==1) return 1;  if (!p) p=1*.3;\n\t\t\tif (a < Math.abs(1)) { a=1; var s=p/4; }\n\t\t\telse var s = p/(2*Math.PI) * Math.asin (1/a);\n\t\t\treturn -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p ));\n\t\t},\n\t\teaseOutElastic: function (t) {\n\t\t\tvar s=1.70158;var p=0;var a=1;\n\t\t\tif (t==0) return 0;  if ((t/=1)==1) return 1;  if (!p) p=1*.3;\n\t\t\tif (a < Math.abs(1)) { a=1; var s=p/4; }\n\t\t\telse var s = p/(2*Math.PI) * Math.asin (1/a);\n\t\t\treturn a*Math.pow(2,-10*t) * Math.sin( (t*1-s)*(2*Math.PI)/p ) + 1;\n\t\t},\n\t\teaseInOutElastic: function (t) {\n\t\t\tvar s=1.70158;var p=0;var a=1;\n\t\t\tif (t==0) return 0;  if ((t/=1/2)==2) return 1;  if (!p) p=1*(.3*1.5);\n\t\t\tif (a < Math.abs(1)) { a=1; var s=p/4; }\n\t\t\telse var s = p/(2*Math.PI) * Math.asin (1/a);\n\t\t\tif (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p ));\n\t\t\treturn a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*1-s)*(2*Math.PI)/p )*.5 + 1;\n\t\t},\n\t\teaseInBack: function (t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn 1*(t/=1)*t*((s+1)*t - s);\n\t\t},\n\t\teaseOutBack: function (t) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn 1*((t=t/1-1)*t*((s+1)*t + s) + 1);\n\t\t},\n\t\teaseInOutBack: function (t) {\n\t\t\tvar s = 1.70158; \n\t\t\tif ((t/=1/2) < 1) return 1/2*(t*t*(((s*=(1.525))+1)*t - s));\n\t\t\treturn 1/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);\n\t\t},\n\t\teaseInBounce: function (t) {\n\t\t\treturn 1 - animationOptions.easeOutBounce (1-t);\n\t\t},\n\t\teaseOutBounce: function (t) {\n\t\t\tif ((t/=1) < (1/2.75)) {\n\t\t\t\treturn 1*(7.5625*t*t);\n\t\t\t} else if (t < (2/2.75)) {\n\t\t\t\treturn 1*(7.5625*(t-=(1.5/2.75))*t + .75);\n\t\t\t} else if (t < (2.5/2.75)) {\n\t\t\t\treturn 1*(7.5625*(t-=(2.25/2.75))*t + .9375);\n\t\t\t} else {\n\t\t\t\treturn 1*(7.5625*(t-=(2.625/2.75))*t + .984375);\n\t\t\t}\n\t\t},\n\t\teaseInOutBounce: function (t) {\n\t\t\tif (t < 1/2) return animationOptions.easeInBounce (t*2) * .5;\n\t\t\treturn animationOptions.easeOutBounce (t*2-1) * .5 + 1*.5;\n\t\t}\n\t};\n\n\t//Variables global to the chart\n\tvar width = context.canvas.width;\n\tvar height = context.canvas.height;\n\n\n\t//High pixel density displays - multiply the size of the canvas height/width by the device pixel ratio, then scale.\n\tif (window.devicePixelRatio) {\n\t\tcontext.canvas.style.width = width + \"px\";\n\t\tcontext.canvas.style.height = height + \"px\";\n\t\tcontext.canvas.height = height * window.devicePixelRatio;\n\t\tcontext.canvas.width = width * window.devicePixelRatio;\n\t\tcontext.scale(window.devicePixelRatio, window.devicePixelRatio);\n\t}\n\n\tthis.PolarArea = function(data,options){\n\t\n\t\tchart.PolarArea.defaults = {\n\t\t\tscaleOverlay : true,\n\t\t\tscaleOverride : false,\n\t\t\tscaleSteps : null,\n\t\t\tscaleStepWidth : null,\n\t\t\tscaleStartValue : null,\n\t\t\tscaleShowLine : true,\n\t\t\tscaleLineColor : \"rgba(0,0,0,.1)\",\n\t\t\tscaleLineWidth : 1,\n\t\t\tscaleShowLabels : true,\n\t\t\tscaleLabel : \"<%=value%>\",\n\t\t\tscaleFontFamily : \"'Arial'\",\n\t\t\tscaleFontSize : 12,\n\t\t\tscaleFontStyle : \"normal\",\n\t\t\tscaleFontColor : \"#666\",\n\t\t\tscaleShowLabelBackdrop : true,\n\t\t\tscaleBackdropColor : \"rgba(255,255,255,0.75)\",\n\t\t\tscaleBackdropPaddingY : 2,\n\t\t\tscaleBackdropPaddingX : 2,\n\t\t\tsegmentShowStroke : true,\n\t\t\tsegmentStrokeColor : \"#fff\",\n\t\t\tsegmentStrokeWidth : 2,\n\t\t\tanimation : true,\n\t\t\tanimationSteps : 100,\n\t\t\tanimationEasing : \"easeOutBounce\",\n\t\t\tanimateRotate : true,\n\t\t\tanimateScale : false,\n\t\t\tonAnimationComplete : null\n\t\t};\n\t\t\n\t\tvar config = (options)? mergeChartConfig(chart.PolarArea.defaults,options) : chart.PolarArea.defaults;\n\t\t\n\t\treturn new PolarArea(data,config,context);\n\t};\n\n\tthis.Radar = function(data,options){\n\t\n\t\tchart.Radar.defaults = {\n\t\t\tscaleOverlay : false,\n\t\t\tscaleOverride : false,\n\t\t\tscaleSteps : null,\n\t\t\tscaleStepWidth : null,\n\t\t\tscaleStartValue : null,\n\t\t\tscaleShowLine : true,\n\t\t\tscaleLineColor : \"rgba(0,0,0,.1)\",\n\t\t\tscaleLineWidth : 1,\n\t\t\tscaleShowLabels : false,\n\t\t\tscaleLabel : \"<%=value%>\",\n\t\t\tscaleFontFamily : \"'Arial'\",\n\t\t\tscaleFontSize : 12,\n\t\t\tscaleFontStyle : \"normal\",\n\t\t\tscaleFontColor : \"#666\",\n\t\t\tscaleShowLabelBackdrop : true,\n\t\t\tscaleBackdropColor : \"rgba(255,255,255,0.75)\",\n\t\t\tscaleBackdropPaddingY : 2,\n\t\t\tscaleBackdropPaddingX : 2,\n\t\t\tangleShowLineOut : true,\n\t\t\tangleLineColor : \"rgba(0,0,0,.1)\",\n\t\t\tangleLineWidth : 1,\t\t\t\n\t\t\tpointLabelFontFamily : \"'Arial'\",\n\t\t\tpointLabelFontStyle : \"normal\",\n\t\t\tpointLabelFontSize : 12,\n\t\t\tpointLabelFontColor : \"#666\",\n\t\t\tpointDot : true,\n\t\t\tpointDotRadius : 3,\n\t\t\tpointDotStrokeWidth : 1,\n\t\t\tdatasetStroke : true,\n\t\t\tdatasetStrokeWidth : 2,\n\t\t\tdatasetFill : true,\n\t\t\tanimation : true,\n\t\t\tanimationSteps : 60,\n\t\t\tanimationEasing : \"easeOutQuart\",\n\t\t\tonAnimationComplete : null\n\t\t};\n\t\t\n\t\tvar config = (options)? mergeChartConfig(chart.Radar.defaults,options) : chart.Radar.defaults;\n\n\t\treturn new Radar(data,config,context);\n\t};\n\t\n\tthis.Pie = function(data,options){\n\t\tchart.Pie.defaults = {\n\t\t\tsegmentShowStroke : true,\n\t\t\tsegmentStrokeColor : \"#fff\",\n\t\t\tsegmentStrokeWidth : 2,\n\t\t\tanimation : true,\n\t\t\tanimationSteps : 100,\n\t\t\tanimationEasing : \"easeOutBounce\",\n\t\t\tanimateRotate : true,\n\t\t\tanimateScale : false,\n\t\t\tonAnimationComplete : null\n\t\t};\t\t\n\n\t\tvar config = (options)? mergeChartConfig(chart.Pie.defaults,options) : chart.Pie.defaults;\n\t\t\n\t\treturn new Pie(data,config,context);\t\t\t\t\n\t};\n\t\n\tthis.Doughnut = function(data,options){\n\t\n\t\tchart.Doughnut.defaults = {\n\t\t\tsegmentShowStroke : true,\n\t\t\tsegmentStrokeColor : \"#fff\",\n\t\t\tsegmentStrokeWidth : 2,\n\t\t\tpercentageInnerCutout : 50,\n\t\t\tanimation : true,\n\t\t\tanimationSteps : 100,\n\t\t\tanimationEasing : \"easeOutBounce\",\n\t\t\tanimateRotate : true,\n\t\t\tanimateScale : false,\n\t\t\tonAnimationComplete : null\n\t\t};\t\t\n\n\t\tvar config = (options)? mergeChartConfig(chart.Doughnut.defaults,options) : chart.Doughnut.defaults;\n\t\t\n\t\treturn new Doughnut(data,config,context);\t\t\t\n\t\t\n\t};\n\n\tthis.Line = function(data,options){\n\t\n\t\tchart.Line.defaults = {\n\t\t\tscaleOverlay : false,\n\t\t\tscaleOverride : false,\n\t\t\tscaleSteps : null,\n\t\t\tscaleStepWidth : null,\n\t\t\tscaleStartValue : null,\n\t\t\tscaleLineColor : \"rgba(0,0,0,.1)\",\n\t\t\tscaleLineWidth : 1,\n\t\t\tscaleShowLabels : true,\n\t\t\tscaleLabel : \"<%=value%>\",\n\t\t\tscaleFontFamily : \"'Arial'\",\n\t\t\tscaleFontSize : 12,\n\t\t\tscaleFontStyle : \"normal\",\n\t\t\tscaleFontColor : \"#666\",\n\t\t\tscaleShowGridLines : true,\n\t\t\tscaleGridLineColor : \"rgba(0,0,0,.05)\",\n\t\t\tscaleGridLineWidth : 1,\n\t\t\tbezierCurve : true,\n\t\t\tpointDot : true,\n\t\t\tpointDotRadius : 4,\n\t\t\tpointDotStrokeWidth : 2,\n\t\t\tdatasetStroke : true,\n\t\t\tdatasetStrokeWidth : 2,\n\t\t\tdatasetFill : true,\n\t\t\tanimation : true,\n\t\t\tanimationSteps : 60,\n\t\t\tanimationEasing : \"easeOutQuart\",\n\t\t\tonAnimationComplete : null\n\t\t};\t\t\n\t\tvar config = (options) ? mergeChartConfig(chart.Line.defaults,options) : chart.Line.defaults;\n\t\t\n\t\treturn new Line(data,config,context);\n\t}\n\t\n\tthis.Bar = function(data,options){\n\t\tchart.Bar.defaults = {\n\t\t\tscaleOverlay : false,\n\t\t\tscaleOverride : false,\n\t\t\tscaleSteps : null,\n\t\t\tscaleStepWidth : null,\n\t\t\tscaleStartValue : null,\n\t\t\tscaleLineColor : \"rgba(0,0,0,.1)\",\n\t\t\tscaleLineWidth : 1,\n\t\t\tscaleShowLabels : true,\n\t\t\tscaleLabel : \"<%=value%>\",\n\t\t\tscaleFontFamily : \"'Arial'\",\n\t\t\tscaleFontSize : 12,\n\t\t\tscaleFontStyle : \"normal\",\n\t\t\tscaleFontColor : \"#666\",\n\t\t\tscaleShowGridLines : true,\n\t\t\tscaleGridLineColor : \"rgba(0,0,0,.05)\",\n\t\t\tscaleGridLineWidth : 1,\n\t\t\tbarShowStroke : true,\n\t\t\tbarStrokeWidth : 2,\n\t\t\tbarValueSpacing : 5,\n\t\t\tbarDatasetSpacing : 1,\n\t\t\tanimation : true,\n\t\t\tanimationSteps : 60,\n\t\t\tanimationEasing : \"easeOutQuart\",\n\t\t\tonAnimationComplete : null\n\t\t};\t\t\n\t\tvar config = (options) ? mergeChartConfig(chart.Bar.defaults,options) : chart.Bar.defaults;\n\t\t\n\t\treturn new Bar(data,config,context);\t\t\n\t}\n\t\n\tvar clear = function(c){\n\t\tc.clearRect(0, 0, width, height);\n\t};\n\n\tvar PolarArea = function(data,config,ctx){\n\t\tvar maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString;\t\t\n\t\t\n\t\t\n\t\tcalculateDrawingSizes();\n\t\t\n\t\tvalueBounds = getValueBounds();\n\n\t\tlabelTemplateString = (config.scaleShowLabels)? config.scaleLabel : null;\n\n\t\t//Check and set the scale\n\t\tif (!config.scaleOverride){\n\t\t\t\n\t\t\tcalculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);\n\t\t}\n\t\telse {\n\t\t\tcalculatedScale = {\n\t\t\t\tsteps : config.scaleSteps,\n\t\t\t\tstepValue : config.scaleStepWidth,\n\t\t\t\tgraphMin : config.scaleStartValue,\n\t\t\t\tlabels : []\n\t\t\t}\n\t\t\tpopulateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);\n\t\t}\n\t\t\n\t\tscaleHop = maxSize/(calculatedScale.steps);\n\n\t\t//Wrap in an animation loop wrapper\n\t\tanimationLoop(config,drawScale,drawAllSegments,ctx);\n\n\t\tfunction calculateDrawingSizes(){\n\t\t\tmaxSize = (Min([width,height])/2);\n\t\t\t//Remove whatever is larger - the font size or line width.\n\t\t\t\n\t\t\tmaxSize -= Max([config.scaleFontSize*0.5,config.scaleLineWidth*0.5]);\n\t\t\t\n\t\t\tlabelHeight = config.scaleFontSize*2;\n\t\t\t//If we're drawing the backdrop - add the Y padding to the label height and remove from drawing region.\n\t\t\tif (config.scaleShowLabelBackdrop){\n\t\t\t\tlabelHeight += (2 * config.scaleBackdropPaddingY);\n\t\t\t\tmaxSize -= config.scaleBackdropPaddingY*1.5;\n\t\t\t}\n\t\t\t\n\t\t\tscaleHeight = maxSize;\n\t\t\t//If the label height is less than 5, set it to 5 so we don't have lines on top of each other.\n\t\t\tlabelHeight = Default(labelHeight,5);\n\t\t}\n\t\tfunction drawScale(){\n\t\t\tfor (var i=0; i<calculatedScale.steps; i++){\n\t\t\t\t//If the line object is there\n\t\t\t\tif (config.scaleShowLine){\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(width/2, height/2, scaleHop * (i + 1), 0, (Math.PI * 2), true);\n\t\t\t\t\tctx.strokeStyle = config.scaleLineColor;\n\t\t\t\t\tctx.lineWidth = config.scaleLineWidth;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (config.scaleShowLabels){\n\t\t\t\t\tctx.textAlign = \"center\";\n\t\t\t\t\tctx.font = config.scaleFontStyle + \" \" + config.scaleFontSize + \"px \" + config.scaleFontFamily;\n \t\t\t\t\tvar label =  calculatedScale.labels[i];\n\t\t\t\t\t//If the backdrop object is within the font object\n\t\t\t\t\tif (config.scaleShowLabelBackdrop){\n\t\t\t\t\t\tvar textWidth = ctx.measureText(label).width;\n\t\t\t\t\t\tctx.fillStyle = config.scaleBackdropColor;\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.rect(\n\t\t\t\t\t\t\tMath.round(width/2 - textWidth/2 - config.scaleBackdropPaddingX),     //X\n\t\t\t\t\t\t\tMath.round(height/2 - (scaleHop * (i + 1)) - config.scaleFontSize*0.5 - config.scaleBackdropPaddingY),//Y\n\t\t\t\t\t\t\tMath.round(textWidth + (config.scaleBackdropPaddingX*2)), //Width\n\t\t\t\t\t\t\tMath.round(config.scaleFontSize + (config.scaleBackdropPaddingY*2)) //Height\n\t\t\t\t\t\t);\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t}\n\t\t\t\t\tctx.textBaseline = \"middle\";\n\t\t\t\t\tctx.fillStyle = config.scaleFontColor;\n\t\t\t\t\tctx.fillText(label,width/2,height/2 - (scaleHop * (i + 1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction drawAllSegments(animationDecimal){\n\t\t\tvar startAngle = -Math.PI/2,\n\t\t\tangleStep = (Math.PI*2)/data.length,\n\t\t\tscaleAnimation = 1,\n\t\t\trotateAnimation = 1;\n\t\t\tif (config.animation) {\n\t\t\t\tif (config.animateScale) {\n\t\t\t\t\tscaleAnimation = animationDecimal;\n\t\t\t\t}\n\t\t\t\tif (config.animateRotate){\n\t\t\t\t\trotateAnimation = animationDecimal;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i=0; i<data.length; i++){\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(width/2,height/2,scaleAnimation * calculateOffset(data[i].value,calculatedScale,scaleHop),startAngle, startAngle + rotateAnimation*angleStep, false);\n\t\t\t\tctx.lineTo(width/2,height/2);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fillStyle = data[i].color;\n\t\t\t\tctx.fill();\n\n\t\t\t\tif(config.segmentShowStroke){\n\t\t\t\t\tctx.strokeStyle = config.segmentStrokeColor;\n\t\t\t\t\tctx.lineWidth = config.segmentStrokeWidth;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\tstartAngle += rotateAnimation*angleStep;\n\t\t\t}\n\t\t}\n\t\tfunction getValueBounds() {\n\t\t\tvar upperValue = Number.MIN_VALUE;\n\t\t\tvar lowerValue = Number.MAX_VALUE;\n\t\t\tfor (var i=0; i<data.length; i++){\n\t\t\t\tif (data[i].value > upperValue) {upperValue = data[i].value;}\n\t\t\t\tif (data[i].value < lowerValue) {lowerValue = data[i].value;}\n\t\t\t};\n\n\t\t\tvar maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));\n\t\t\tvar minSteps = Math.floor((scaleHeight / labelHeight*0.5));\n\t\t\t\n\t\t\treturn {\n\t\t\t\tmaxValue : upperValue,\n\t\t\t\tminValue : lowerValue,\n\t\t\t\tmaxSteps : maxSteps,\n\t\t\t\tminSteps : minSteps\n\t\t\t};\n\t\t\t\n\n\t\t}\n\t}\n\n\tvar Radar = function (data,config,ctx) {\n\t\tvar maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString;\t\n\t\t\t\n\t\t//If no labels are defined set to an empty array, so referencing length for looping doesn't blow up.\n\t\tif (!data.labels) data.labels = [];\n\t\t\n\t\tcalculateDrawingSizes();\n\n\t\tvar valueBounds = getValueBounds();\n\n\t\tlabelTemplateString = (config.scaleShowLabels)? config.scaleLabel : null;\n\n\t\t//Check and set the scale\n\t\tif (!config.scaleOverride){\n\t\t\t\n\t\t\tcalculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);\n\t\t}\n\t\telse {\n\t\t\tcalculatedScale = {\n\t\t\t\tsteps : config.scaleSteps,\n\t\t\t\tstepValue : config.scaleStepWidth,\n\t\t\t\tgraphMin : config.scaleStartValue,\n\t\t\t\tlabels : []\n\t\t\t}\n\t\t\tpopulateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);\n\t\t}\n\t\t\n\t\tscaleHop = maxSize/(calculatedScale.steps);\n\t\t\n\t\tanimationLoop(config,drawScale,drawAllDataPoints,ctx);\n\t\t\n\t\t//Radar specific functions.\n\t\tfunction drawAllDataPoints(animationDecimal){\n\t\t\tvar rotationDegree = (2*Math.PI)/data.datasets[0].data.length;\n\n\t\t\tctx.save();\n\t\t\t//translate to the centre of the canvas.\n\t\t\tctx.translate(width/2,height/2);\n\t\t\t\n\t\t\t//We accept multiple data sets for radar charts, so show loop through each set\n\t\t\tfor (var i=0; i<data.datasets.length; i++){\n\t\t\t\tctx.beginPath();\n\n\t\t\t\tctx.moveTo(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[0],calculatedScale,scaleHop)));\n\t\t\t\tfor (var j=1; j<data.datasets[i].data.length; j++){\n\t\t\t\t\tctx.rotate(rotationDegree);\t\n\t\t\t\t\tctx.lineTo(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)));\n\t\t\t\n\t\t\t\t}\n\t\t\t\tctx.closePath();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tctx.fillStyle = data.datasets[i].fillColor;\n\t\t\t\tctx.strokeStyle = data.datasets[i].strokeColor;\n\t\t\t\tctx.lineWidth = config.datasetStrokeWidth;\n\t\t\t\tctx.fill();\n\t\t\t\tctx.stroke();\n\t\t\t\t\n\t\t\t\t\t\t\t\t\n\t\t\t\tif (config.pointDot){\n\t\t\t\t\tctx.fillStyle = data.datasets[i].pointColor;\n\t\t\t\t\tctx.strokeStyle = data.datasets[i].pointStrokeColor;\n\t\t\t\t\tctx.lineWidth = config.pointDotStrokeWidth;\n\t\t\t\t\tfor (var k=0; k<data.datasets[i].data.length; k++){\n\t\t\t\t\t\tctx.rotate(rotationDegree);\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.arc(0,animationDecimal*(-1*calculateOffset(data.datasets[i].data[k],calculatedScale,scaleHop)),config.pointDotRadius,2*Math.PI,false);\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tctx.rotate(rotationDegree);\n\t\t\t\t\n\t\t\t}\n\t\t\tctx.restore();\n\t\t\t\n\t\t\t\n\t\t}\n\t\tfunction drawScale(){\n\t\t\tvar rotationDegree = (2*Math.PI)/data.datasets[0].data.length;\n\t\t\tctx.save();\n\t\t    ctx.translate(width / 2, height / 2);\t\n\t\t\t\n\t\t\tif (config.angleShowLineOut){\n\t\t\t\tctx.strokeStyle = config.angleLineColor;\t\t    \t    \n\t\t\t\tctx.lineWidth = config.angleLineWidth;\n\t\t\t\tfor (var h=0; h<data.datasets[0].data.length; h++){\n\t\t\t\t\t\n\t\t\t\t    ctx.rotate(rotationDegree);\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(0,0);\n\t\t\t\t\tctx.lineTo(0,-maxSize);\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i=0; i<calculatedScale.steps; i++){\n\t\t\t\tctx.beginPath();\n\t\t\t\t\n\t\t\t\tif(config.scaleShowLine){\n\t\t\t\t\tctx.strokeStyle = config.scaleLineColor;\n\t\t\t\t\tctx.lineWidth = config.scaleLineWidth;\n\t\t\t\t\tctx.moveTo(0,-scaleHop * (i+1));\t\t\t\t\t\n\t\t\t\t\tfor (var j=0; j<data.datasets[0].data.length; j++){\n\t\t\t\t\t    ctx.rotate(rotationDegree);\n\t\t\t\t\t\tctx.lineTo(0,-scaleHop * (i+1));\n\t\t\t\t\t}\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.stroke();\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (config.scaleShowLabels){\t\t\t\t\n\t\t\t\t\tctx.textAlign = 'center';\n\t\t\t\t\tctx.font = config.scaleFontStyle + \" \" + config.scaleFontSize+\"px \" + config.scaleFontFamily; \n\t\t\t\t\tctx.textBaseline = \"middle\";\n\t\t\t\t\t\n\t\t\t\t\tif (config.scaleShowLabelBackdrop){\n\t\t\t\t\t\tvar textWidth = ctx.measureText(calculatedScale.labels[i]).width;\n\t\t\t\t\t\tctx.fillStyle = config.scaleBackdropColor;\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.rect(\n\t\t\t\t\t\t\tMath.round(- textWidth/2 - config.scaleBackdropPaddingX),     //X\n\t\t\t\t\t\t\tMath.round((-scaleHop * (i + 1)) - config.scaleFontSize*0.5 - config.scaleBackdropPaddingY),//Y\n\t\t\t\t\t\t\tMath.round(textWidth + (config.scaleBackdropPaddingX*2)), //Width\n\t\t\t\t\t\t\tMath.round(config.scaleFontSize + (config.scaleBackdropPaddingY*2)) //Height\n\t\t\t\t\t\t);\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t}\t\t\t\t\t\t\n\t\t\t\t\tctx.fillStyle = config.scaleFontColor;\n\t\t\t\t\tctx.fillText(calculatedScale.labels[i],0,-scaleHop*(i+1));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tfor (var k=0; k<data.labels.length; k++){\t\t\t\t\n\t\t\tctx.font = config.pointLabelFontStyle + \" \" + config.pointLabelFontSize+\"px \" + config.pointLabelFontFamily;\n\t\t\tctx.fillStyle = config.pointLabelFontColor;\n\t\t\t\tvar opposite = Math.sin(rotationDegree*k) * (maxSize + config.pointLabelFontSize);\n\t\t\t\tvar adjacent = Math.cos(rotationDegree*k) * (maxSize + config.pointLabelFontSize);\n\t\t\t\t\n\t\t\t\tif(rotationDegree*k == Math.PI || rotationDegree*k == 0){\n\t\t\t\t\tctx.textAlign = \"center\";\n\t\t\t\t}\n\t\t\t\telse if(rotationDegree*k > Math.PI){\n\t\t\t\t\tctx.textAlign = \"right\";\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tctx.textAlign = \"left\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.textBaseline = \"middle\";\n\t\t\t\t\n\t\t\t\tctx.fillText(data.labels[k],opposite,-adjacent);\n\t\t\t\t\n\t\t\t}\n\t\t\tctx.restore();\n\t\t};\n\t\tfunction calculateDrawingSizes(){\n\t\t\tmaxSize = (Min([width,height])/2);\n\n\t\t\tlabelHeight = config.scaleFontSize*2;\n\t\t\t\n\t\t\tvar labelLength = 0;\n\t\t\tfor (var i=0; i<data.labels.length; i++){\n\t\t\t\tctx.font = config.pointLabelFontStyle + \" \" + config.pointLabelFontSize+\"px \" + config.pointLabelFontFamily;\n\t\t\t\tvar textMeasurement = ctx.measureText(data.labels[i]).width;\n\t\t\t\tif(textMeasurement>labelLength) labelLength = textMeasurement;\n\t\t\t}\n\t\t\t\n\t\t\t//Figure out whats the largest - the height of the text or the width of what's there, and minus it from the maximum usable size.\n\t\t\tmaxSize -= Max([labelLength,((config.pointLabelFontSize/2)*1.5)]);\t\t\t\t\n\t\t\t\n\t\t\tmaxSize -= config.pointLabelFontSize;\n\t\t\tmaxSize = CapValue(maxSize, null, 0);\n\t\t\tscaleHeight = maxSize;\n\t\t\t//If the label height is less than 5, set it to 5 so we don't have lines on top of each other.\n\t\t\tlabelHeight = Default(labelHeight,5);\n\t\t};\n\t\tfunction getValueBounds() {\n\t\t\tvar upperValue = Number.MIN_VALUE;\n\t\t\tvar lowerValue = Number.MAX_VALUE;\n\t\t\t\n\t\t\tfor (var i=0; i<data.datasets.length; i++){\n\t\t\t\tfor (var j=0; j<data.datasets[i].data.length; j++){\n\t\t\t\t\tif (data.datasets[i].data[j] > upperValue){upperValue = data.datasets[i].data[j]}\n\t\t\t\t\tif (data.datasets[i].data[j] < lowerValue){lowerValue = data.datasets[i].data[j]}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));\n\t\t\tvar minSteps = Math.floor((scaleHeight / labelHeight*0.5));\n\t\t\t\n\t\t\treturn {\n\t\t\t\tmaxValue : upperValue,\n\t\t\t\tminValue : lowerValue,\n\t\t\t\tmaxSteps : maxSteps,\n\t\t\t\tminSteps : minSteps\n\t\t\t};\n\t\t\t\n\n\t\t}\n\t}\n\n\tvar Pie = function(data,config,ctx){\n\t\tvar segmentTotal = 0;\n\t\t\n\t\t//In case we have a canvas that is not a square. Minus 5 pixels as padding round the edge.\n\t\tvar pieRadius = Min([height/2,width/2]) - 5;\n\t\t\n\t\tfor (var i=0; i<data.length; i++){\n\t\t\tsegmentTotal += data[i].value;\n\t\t}\n\t\t\n\t\t\n\t\tanimationLoop(config,null,drawPieSegments,ctx);\n\t\t\t\t\n\t\tfunction drawPieSegments (animationDecimal){\n\t\t\tvar cumulativeAngle = -Math.PI/2,\n\t\t\tscaleAnimation = 1,\n\t\t\trotateAnimation = 1;\n\t\t\tif (config.animation) {\n\t\t\t\tif (config.animateScale) {\n\t\t\t\t\tscaleAnimation = animationDecimal;\n\t\t\t\t}\n\t\t\t\tif (config.animateRotate){\n\t\t\t\t\trotateAnimation = animationDecimal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i=0; i<data.length; i++){\n\t\t\t\tvar segmentAngle = rotateAnimation * ((data[i].value/segmentTotal) * (Math.PI*2));\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(width/2,height/2,scaleAnimation * pieRadius,cumulativeAngle,cumulativeAngle + segmentAngle);\n\t\t\t\tctx.lineTo(width/2,height/2);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fillStyle = data[i].color;\n\t\t\t\tctx.fill();\n\t\t\t\t\n\t\t\t\tif(config.segmentShowStroke){\n\t\t\t\t\tctx.lineWidth = config.segmentStrokeWidth;\n\t\t\t\t\tctx.strokeStyle = config.segmentStrokeColor;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\tcumulativeAngle += segmentAngle;\n\t\t\t}\t\t\t\n\t\t}\t\t\n\t}\n\n\tvar Doughnut = function(data,config,ctx){\n\t\tvar segmentTotal = 0;\n\t\t\n\t\t//In case we have a canvas that is not a square. Minus 5 pixels as padding round the edge.\n\t\tvar doughnutRadius = Min([height/2,width/2]) - 5;\n\t\t\n\t\tvar cutoutRadius = doughnutRadius * (config.percentageInnerCutout/100);\n\t\t\n\t\tfor (var i=0; i<data.length; i++){\n\t\t\tsegmentTotal += data[i].value;\n\t\t}\n\t\t\n\t\t\n\t\tanimationLoop(config,null,drawPieSegments,ctx);\n\t\t\n\t\t\n\t\tfunction drawPieSegments (animationDecimal){\n\t\t\tvar cumulativeAngle = -Math.PI/2,\n\t\t\tscaleAnimation = 1,\n\t\t\trotateAnimation = 1;\n\t\t\tif (config.animation) {\n\t\t\t\tif (config.animateScale) {\n\t\t\t\t\tscaleAnimation = animationDecimal;\n\t\t\t\t}\n\t\t\t\tif (config.animateRotate){\n\t\t\t\t\trotateAnimation = animationDecimal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i=0; i<data.length; i++){\n\t\t\t\tvar segmentAngle = rotateAnimation * ((data[i].value/segmentTotal) * (Math.PI*2));\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.arc(width/2,height/2,scaleAnimation * doughnutRadius,cumulativeAngle,cumulativeAngle + segmentAngle,false);\n\t\t\t\tctx.arc(width/2,height/2,scaleAnimation * cutoutRadius,cumulativeAngle + segmentAngle,cumulativeAngle,true);\n\t\t\t\tctx.closePath();\n\t\t\t\tctx.fillStyle = data[i].color;\n\t\t\t\tctx.fill();\n\t\t\t\t\n\t\t\t\tif(config.segmentShowStroke){\n\t\t\t\t\tctx.lineWidth = config.segmentStrokeWidth;\n\t\t\t\t\tctx.strokeStyle = config.segmentStrokeColor;\n\t\t\t\t\tctx.stroke();\n\t\t\t\t}\n\t\t\t\tcumulativeAngle += segmentAngle;\n\t\t\t}\t\t\t\n\t\t}\t\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\n\tvar Line = function(data,config,ctx){\n\t\tvar maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop,widestXLabel, xAxisLength,yAxisPosX,xAxisPosY, rotateLabels = 0;\n\t\t\t\n\t\tcalculateDrawingSizes();\n\t\t\n\t\tvalueBounds = getValueBounds();\n\t\t//Check and set the scale\n\t\tlabelTemplateString = (config.scaleShowLabels)? config.scaleLabel : \"\";\n\t\tif (!config.scaleOverride){\n\t\t\t\n\t\t\tcalculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);\n\t\t}\n\t\telse {\n\t\t\tcalculatedScale = {\n\t\t\t\tsteps : config.scaleSteps,\n\t\t\t\tstepValue : config.scaleStepWidth,\n\t\t\t\tgraphMin : config.scaleStartValue,\n\t\t\t\tlabels : []\n\t\t\t}\n\t\t\tpopulateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);\n\t\t}\n\t\t\n\t\tscaleHop = Math.floor(scaleHeight/calculatedScale.steps);\n\t\tcalculateXAxisSize();\n\t\tanimationLoop(config,drawScale,drawLines,ctx);\t\t\n\t\t\n\t\tfunction drawLines(animPc){\n\t\t\tfor (var i=0; i<data.datasets.length; i++){\n\t\t\t\tctx.strokeStyle = data.datasets[i].strokeColor;\n\t\t\t\tctx.lineWidth = config.datasetStrokeWidth;\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(yAxisPosX, xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[0],calculatedScale,scaleHop)))\n\n\t\t\t\tfor (var j=1; j<data.datasets[i].data.length; j++){\n\t\t\t\t\tif (config.bezierCurve){\n\t\t\t\t\t\tctx.bezierCurveTo(xPos(j-0.5),yPos(i,j-1),xPos(j-0.5),yPos(i,j),xPos(j),yPos(i,j));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tctx.lineTo(xPos(j),yPos(i,j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.stroke();\n\t\t\t\tif (config.datasetFill){\n\t\t\t\t\tctx.lineTo(yAxisPosX + (valueHop*(data.datasets[i].data.length-1)),xAxisPosY);\n\t\t\t\t\tctx.lineTo(yAxisPosX,xAxisPosY);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.fillStyle = data.datasets[i].fillColor;\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\t\t\t\tif(config.pointDot){\n\t\t\t\t\tctx.fillStyle = data.datasets[i].pointColor;\n\t\t\t\t\tctx.strokeStyle = data.datasets[i].pointStrokeColor;\n\t\t\t\t\tctx.lineWidth = config.pointDotStrokeWidth;\n\t\t\t\t\tfor (var k=0; k<data.datasets[i].data.length; k++){\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.arc(yAxisPosX + (valueHop *k),xAxisPosY - animPc*(calculateOffset(data.datasets[i].data[k],calculatedScale,scaleHop)),config.pointDotRadius,0,Math.PI*2,true);\n\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfunction yPos(dataSet,iteration){\n\t\t\t\treturn xAxisPosY - animPc*(calculateOffset(data.datasets[dataSet].data[iteration],calculatedScale,scaleHop));\t\t\t\n\t\t\t}\n\t\t\tfunction xPos(iteration){\n\t\t\t\treturn yAxisPosX + (valueHop * iteration);\n\t\t\t}\n\t\t}\n\t\tfunction drawScale(){\n\t\t\t//X axis line\n\t\t\tctx.lineWidth = config.scaleLineWidth;\n\t\t\tctx.strokeStyle = config.scaleLineColor;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(width-widestXLabel/2+5,xAxisPosY);\n\t\t\tctx.lineTo(width-(widestXLabel/2)-xAxisLength-5,xAxisPosY);\n\t\t\tctx.stroke();\n\t\t\t\n\t\t\t\n\t\t\tif (rotateLabels > 0){\n\t\t\t\tctx.save();\n\t\t\t\tctx.textAlign = \"right\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\tctx.textAlign = \"center\";\n\t\t\t}\n\t\t\tctx.fillStyle = config.scaleFontColor;\n\t\t\tfor (var i=0; i<data.labels.length; i++){\n\t\t\t\tctx.save();\n\t\t\t\tif (rotateLabels > 0){\n\t\t\t\t\tctx.translate(yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize);\n\t\t\t\t\tctx.rotate(-(rotateLabels * (Math.PI/180)));\n\t\t\t\t\tctx.fillText(data.labels[i], 0,0);\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\t\tctx.fillText(data.labels[i], yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize+3);\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(yAxisPosX + i * valueHop, xAxisPosY+3);\n\t\t\t\t\n\t\t\t\t//Check i isnt 0, so we dont go over the Y axis twice.\n\t\t\t\tif(config.scaleShowGridLines && i>0){\n\t\t\t\t\tctx.lineWidth = config.scaleGridLineWidth;\n\t\t\t\t\tctx.strokeStyle = config.scaleGridLineColor;\t\t\t\t\t\n\t\t\t\t\tctx.lineTo(yAxisPosX + i * valueHop, 5);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tctx.lineTo(yAxisPosX + i * valueHop, xAxisPosY+3);\t\t\t\t\n\t\t\t\t}\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t\t\n\t\t\t//Y axis\n\t\t\tctx.lineWidth = config.scaleLineWidth;\n\t\t\tctx.strokeStyle = config.scaleLineColor;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(yAxisPosX,xAxisPosY+5);\n\t\t\tctx.lineTo(yAxisPosX,5);\n\t\t\tctx.stroke();\n\t\t\t\n\t\t\tctx.textAlign = \"right\";\n\t\t\tctx.textBaseline = \"middle\";\n\t\t\tfor (var j=0; j<calculatedScale.steps; j++){\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(yAxisPosX-3,xAxisPosY - ((j+1) * scaleHop));\n\t\t\t\tif (config.scaleShowGridLines){\n\t\t\t\t\tctx.lineWidth = config.scaleGridLineWidth;\n\t\t\t\t\tctx.strokeStyle = config.scaleGridLineColor;\n\t\t\t\t\tctx.lineTo(yAxisPosX + xAxisLength + 5,xAxisPosY - ((j+1) * scaleHop));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tctx.lineTo(yAxisPosX-0.5,xAxisPosY - ((j+1) * scaleHop));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.stroke();\n\t\t\t\t\n\t\t\t\tif (config.scaleShowLabels){\n\t\t\t\t\tctx.fillText(calculatedScale.labels[j],yAxisPosX-8,xAxisPosY - ((j+1) * scaleHop));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tfunction calculateXAxisSize(){\n\t\t\tvar longestText = 1;\n\t\t\t//if we are showing the labels\n\t\t\tif (config.scaleShowLabels){\n\t\t\t\tctx.font = config.scaleFontStyle + \" \" + config.scaleFontSize+\"px \" + config.scaleFontFamily;\n\t\t\t\tfor (var i=0; i<calculatedScale.labels.length; i++){\n\t\t\t\t\tvar measuredText = ctx.measureText(calculatedScale.labels[i]).width;\n\t\t\t\t\tlongestText = (measuredText > longestText)? measuredText : longestText;\n\t\t\t\t}\n\t\t\t\t//Add a little extra padding from the y axis\n\t\t\t\tlongestText +=10;\n\t\t\t}\n\t\t\txAxisLength = width - longestText - widestXLabel;\n\t\t\tvalueHop = Math.floor(xAxisLength/(data.labels.length-1));\t\n\t\t\t\t\n\t\t\tyAxisPosX = width-widestXLabel/2-xAxisLength;\n\t\t\txAxisPosY = scaleHeight + config.scaleFontSize/2;\t\t\t\t\n\t\t}\t\t\n\t\tfunction calculateDrawingSizes(){\n\t\t\tmaxSize = height;\n\n\t\t\t//Need to check the X axis first - measure the length of each text metric, and figure out if we need to rotate by 45 degrees.\n\t\t\tctx.font = config.scaleFontStyle + \" \" + config.scaleFontSize+\"px \" + config.scaleFontFamily;\n\t\t\twidestXLabel = 1;\n\t\t\tfor (var i=0; i<data.labels.length; i++){\n\t\t\t\tvar textLength = ctx.measureText(data.labels[i]).width;\n\t\t\t\t//If the text length is longer - make that equal to longest text!\n\t\t\t\twidestXLabel = (textLength > widestXLabel)? textLength : widestXLabel;\n\t\t\t}\n\t\t\tif (width/data.labels.length < widestXLabel){\n\t\t\t\trotateLabels = 45;\n\t\t\t\tif (width/data.labels.length < Math.cos(rotateLabels) * widestXLabel){\n\t\t\t\t\trotateLabels = 90;\n\t\t\t\t\tmaxSize -= widestXLabel; \n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmaxSize -= Math.sin(rotateLabels) * widestXLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmaxSize -= config.scaleFontSize;\n\t\t\t}\n\t\t\t\n\t\t\t//Add a little padding between the x line and the text\n\t\t\tmaxSize -= 5;\n\t\t\t\n\t\t\t\n\t\t\tlabelHeight = config.scaleFontSize;\n\t\t\t\n\t\t\tmaxSize -= labelHeight;\n\t\t\t//Set 5 pixels greater than the font size to allow for a little padding from the X axis.\n\t\t\t\n\t\t\tscaleHeight = maxSize;\n\t\t\t\n\t\t\t//Then get the area above we can safely draw on.\n\t\t\t\n\t\t}\t\t\n\t\tfunction getValueBounds() {\n\t\t\tvar upperValue = Number.MIN_VALUE;\n\t\t\tvar lowerValue = Number.MAX_VALUE;\n\t\t\tfor (var i=0; i<data.datasets.length; i++){\n\t\t\t\tfor (var j=0; j<data.datasets[i].data.length; j++){\n\t\t\t\t\tif ( data.datasets[i].data[j] > upperValue) { upperValue = data.datasets[i].data[j] };\n\t\t\t\t\tif ( data.datasets[i].data[j] < lowerValue) { lowerValue = data.datasets[i].data[j] };\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tvar maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));\n\t\t\tvar minSteps = Math.floor((scaleHeight / labelHeight*0.5));\n\t\t\t\n\t\t\treturn {\n\t\t\t\tmaxValue : upperValue,\n\t\t\t\tminValue : lowerValue,\n\t\t\t\tmaxSteps : maxSteps,\n\t\t\t\tminSteps : minSteps\n\t\t\t};\n\t\t\t\n\t\n\t\t}\n\n\t\t\n\t}\n\t\n\tvar Bar = function(data,config,ctx){\n\t\tvar maxSize, scaleHop, calculatedScale, labelHeight, scaleHeight, valueBounds, labelTemplateString, valueHop,widestXLabel, xAxisLength,yAxisPosX,xAxisPosY,barWidth, rotateLabels = 0;\n\t\t\t\n\t\tcalculateDrawingSizes();\n\t\t\n\t\tvalueBounds = getValueBounds();\n\t\t//Check and set the scale\n\t\tlabelTemplateString = (config.scaleShowLabels)? config.scaleLabel : \"\";\n\t\tif (!config.scaleOverride){\n\t\t\t\n\t\t\tcalculatedScale = calculateScale(scaleHeight,valueBounds.maxSteps,valueBounds.minSteps,valueBounds.maxValue,valueBounds.minValue,labelTemplateString);\n\t\t}\n\t\telse {\n\t\t\tcalculatedScale = {\n\t\t\t\tsteps : config.scaleSteps,\n\t\t\t\tstepValue : config.scaleStepWidth,\n\t\t\t\tgraphMin : config.scaleStartValue,\n\t\t\t\tlabels : []\n\t\t\t}\n\t\t\tpopulateLabels(labelTemplateString, calculatedScale.labels,calculatedScale.steps,config.scaleStartValue,config.scaleStepWidth);\n\t\t}\n\t\t\n\t\tscaleHop = Math.floor(scaleHeight/calculatedScale.steps);\n\t\tcalculateXAxisSize();\n\t\tanimationLoop(config,drawScale,drawBars,ctx);\t\t\n\t\t\n\t\tfunction drawBars(animPc){\n\t\t\tctx.lineWidth = config.barStrokeWidth;\n\t\t\tfor (var i=0; i<data.datasets.length; i++){\n\t\t\t\t\tctx.fillStyle = data.datasets[i].fillColor;\n\t\t\t\t\tctx.strokeStyle = data.datasets[i].strokeColor;\n\t\t\t\tfor (var j=0; j<data.datasets[i].data.length; j++){\n\t\t\t\t\tvar barOffset = yAxisPosX + config.barValueSpacing + valueHop*j + barWidth*i + config.barDatasetSpacing*i + config.barStrokeWidth*i;\n\t\t\t\t\t\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(barOffset, xAxisPosY);\n\t\t\t\t\tctx.lineTo(barOffset, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));\n\t\t\t\t\tctx.lineTo(barOffset + barWidth, xAxisPosY - animPc*calculateOffset(data.datasets[i].data[j],calculatedScale,scaleHop)+(config.barStrokeWidth/2));\n\t\t\t\t\tctx.lineTo(barOffset + barWidth, xAxisPosY);\n\t\t\t\t\tif(config.barShowStroke){\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.fill();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tfunction drawScale(){\n\t\t\t//X axis line\n\t\t\tctx.lineWidth = config.scaleLineWidth;\n\t\t\tctx.strokeStyle = config.scaleLineColor;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(width-widestXLabel/2+5,xAxisPosY);\n\t\t\tctx.lineTo(width-(widestXLabel/2)-xAxisLength-5,xAxisPosY);\n\t\t\tctx.stroke();\n\t\t\t\n\t\t\t\n\t\t\tif (rotateLabels > 0){\n\t\t\t\tctx.save();\n\t\t\t\tctx.textAlign = \"right\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\tctx.textAlign = \"center\";\n\t\t\t}\n\t\t\tctx.fillStyle = config.scaleFontColor;\n\t\t\tfor (var i=0; i<data.labels.length; i++){\n\t\t\t\tctx.save();\n\t\t\t\tif (rotateLabels > 0){\n\t\t\t\t\tctx.translate(yAxisPosX + i*valueHop,xAxisPosY + config.scaleFontSize);\n\t\t\t\t\tctx.rotate(-(rotateLabels * (Math.PI/180)));\n\t\t\t\t\tctx.fillText(data.labels[i], 0,0);\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse{\n\t\t\t\t\tctx.fillText(data.labels[i], yAxisPosX + i*valueHop + valueHop/2,xAxisPosY + config.scaleFontSize+3);\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(yAxisPosX + (i+1) * valueHop, xAxisPosY+3);\n\t\t\t\t\n\t\t\t\t//Check i isnt 0, so we dont go over the Y axis twice.\n\t\t\t\t\tctx.lineWidth = config.scaleGridLineWidth;\n\t\t\t\t\tctx.strokeStyle = config.scaleGridLineColor;\t\t\t\t\t\n\t\t\t\t\tctx.lineTo(yAxisPosX + (i+1) * valueHop, 5);\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t\t\n\t\t\t//Y axis\n\t\t\tctx.lineWidth = config.scaleLineWidth;\n\t\t\tctx.strokeStyle = config.scaleLineColor;\n\t\t\tctx.beginPath();\n\t\t\tctx.moveTo(yAxisPosX,xAxisPosY+5);\n\t\t\tctx.lineTo(yAxisPosX,5);\n\t\t\tctx.stroke();\n\t\t\t\n\t\t\tctx.textAlign = \"right\";\n\t\t\tctx.textBaseline = \"middle\";\n\t\t\tfor (var j=0; j<calculatedScale.steps; j++){\n\t\t\t\tctx.beginPath();\n\t\t\t\tctx.moveTo(yAxisPosX-3,xAxisPosY - ((j+1) * scaleHop));\n\t\t\t\tif (config.scaleShowGridLines){\n\t\t\t\t\tctx.lineWidth = config.scaleGridLineWidth;\n\t\t\t\t\tctx.strokeStyle = config.scaleGridLineColor;\n\t\t\t\t\tctx.lineTo(yAxisPosX + xAxisLength + 5,xAxisPosY - ((j+1) * scaleHop));\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tctx.lineTo(yAxisPosX-0.5,xAxisPosY - ((j+1) * scaleHop));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.stroke();\n\t\t\t\tif (config.scaleShowLabels){\n\t\t\t\t\tctx.fillText(calculatedScale.labels[j],yAxisPosX-8,xAxisPosY - ((j+1) * scaleHop));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\tfunction calculateXAxisSize(){\n\t\t\tvar longestText = 1;\n\t\t\t//if we are showing the labels\n\t\t\tif (config.scaleShowLabels){\n\t\t\t\tctx.font = config.scaleFontStyle + \" \" + config.scaleFontSize+\"px \" + config.scaleFontFamily;\n\t\t\t\tfor (var i=0; i<calculatedScale.labels.length; i++){\n\t\t\t\t\tvar measuredText = ctx.measureText(calculatedScale.labels[i]).width;\n\t\t\t\t\tlongestText = (measuredText > longestText)? measuredText : longestText;\n\t\t\t\t}\n\t\t\t\t//Add a little extra padding from the y axis\n\t\t\t\tlongestText +=10;\n\t\t\t}\n\t\t\txAxisLength = width - longestText - widestXLabel;\n\t\t\tvalueHop = Math.floor(xAxisLength/(data.labels.length));\t\n\t\t\t\n\t\t\tbarWidth = (valueHop - config.scaleGridLineWidth*2 - (config.barValueSpacing*2) - (config.barDatasetSpacing*data.datasets.length-1) - ((config.barStrokeWidth/2)*data.datasets.length-1))/data.datasets.length;\n\t\t\t\n\t\t\tyAxisPosX = width-widestXLabel/2-xAxisLength;\n\t\t\txAxisPosY = scaleHeight + config.scaleFontSize/2;\t\t\t\t\n\t\t}\t\t\n\t\tfunction calculateDrawingSizes(){\n\t\t\tmaxSize = height;\n\n\t\t\t//Need to check the X axis first - measure the length of each text metric, and figure out if we need to rotate by 45 degrees.\n\t\t\tctx.font = config.scaleFontStyle + \" \" + config.scaleFontSize+\"px \" + config.scaleFontFamily;\n\t\t\twidestXLabel = 1;\n\t\t\tfor (var i=0; i<data.labels.length; i++){\n\t\t\t\tvar textLength = ctx.measureText(data.labels[i]).width;\n\t\t\t\t//If the text length is longer - make that equal to longest text!\n\t\t\t\twidestXLabel = (textLength > widestXLabel)? textLength : widestXLabel;\n\t\t\t}\n\t\t\tif (width/data.labels.length < widestXLabel){\n\t\t\t\trotateLabels = 45;\n\t\t\t\tif (width/data.labels.length < Math.cos(rotateLabels) * widestXLabel){\n\t\t\t\t\trotateLabels = 90;\n\t\t\t\t\tmaxSize -= widestXLabel; \n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmaxSize -= Math.sin(rotateLabels) * widestXLabel;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmaxSize -= config.scaleFontSize;\n\t\t\t}\n\t\t\t\n\t\t\t//Add a little padding between the x line and the text\n\t\t\tmaxSize -= 5;\n\t\t\t\n\t\t\t\n\t\t\tlabelHeight = config.scaleFontSize;\n\t\t\t\n\t\t\tmaxSize -= labelHeight;\n\t\t\t//Set 5 pixels greater than the font size to allow for a little padding from the X axis.\n\t\t\t\n\t\t\tscaleHeight = maxSize;\n\t\t\t\n\t\t\t//Then get the area above we can safely draw on.\n\t\t\t\n\t\t}\t\t\n\t\tfunction getValueBounds() {\n\t\t\tvar upperValue = Number.MIN_VALUE;\n\t\t\tvar lowerValue = Number.MAX_VALUE;\n\t\t\tfor (var i=0; i<data.datasets.length; i++){\n\t\t\t\tfor (var j=0; j<data.datasets[i].data.length; j++){\n\t\t\t\t\tif ( data.datasets[i].data[j] > upperValue) { upperValue = data.datasets[i].data[j] };\n\t\t\t\t\tif ( data.datasets[i].data[j] < lowerValue) { lowerValue = data.datasets[i].data[j] };\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tvar maxSteps = Math.floor((scaleHeight / (labelHeight*0.66)));\n\t\t\tvar minSteps = Math.floor((scaleHeight / labelHeight*0.5));\n\t\t\t\n\t\t\treturn {\n\t\t\t\tmaxValue : upperValue,\n\t\t\t\tminValue : lowerValue,\n\t\t\t\tmaxSteps : maxSteps,\n\t\t\t\tminSteps : minSteps\n\t\t\t};\n\t\t\t\n\t\n\t\t}\n\t}\n\t\n\tfunction calculateOffset(val,calculatedScale,scaleHop){\n\t\tvar outerValue = calculatedScale.steps * calculatedScale.stepValue;\n\t\tvar adjustedValue = val - calculatedScale.graphMin;\n\t\tvar scalingFactor = CapValue(adjustedValue/outerValue,1,0);\n\t\treturn (scaleHop*calculatedScale.steps) * scalingFactor;\n\t}\n\t\n\tfunction animationLoop(config,drawScale,drawData,ctx){\n\t\tvar animFrameAmount = (config.animation)? 1/CapValue(config.animationSteps,Number.MAX_VALUE,1) : 1,\n\t\t\teasingFunction = animationOptions[config.animationEasing],\n\t\t\tpercentAnimComplete =(config.animation)? 0 : 1;\n\t\t\n\t\n\t\t\n\t\tif (typeof drawScale !== \"function\") drawScale = function(){};\n\t\t\n\t\trequestAnimFrame(animLoop);\n\t\t\n\t\tfunction animateFrame(){\n\t\t\tvar easeAdjustedAnimationPercent =(config.animation)? CapValue(easingFunction(percentAnimComplete),null,0) : 1;\n\t\t\tclear(ctx);\n\t\t\tif(config.scaleOverlay){\n\t\t\t\tdrawData(easeAdjustedAnimationPercent);\n\t\t\t\tdrawScale();\n\t\t\t} else {\n\t\t\t\tdrawScale();\n\t\t\t\tdrawData(easeAdjustedAnimationPercent);\n\t\t\t}\t\t\t\t\n\t\t}\n\t\tfunction animLoop(){\n\t\t\t//We need to check if the animation is incomplete (less than 1), or complete (1).\n\t\t\t\tpercentAnimComplete += animFrameAmount;\n\t\t\t\tanimateFrame();\t\n\t\t\t\t//Stop the loop continuing forever\n\t\t\t\tif (percentAnimComplete <= 1){\n\t\t\t\t\trequestAnimFrame(animLoop);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (typeof config.onAnimationComplete == \"function\") config.onAnimationComplete();\n\t\t\t\t}\n\t\t\t\n\t\t}\t\t\n\t\t\n\t}\n\n\t//Declare global functions to be called within this namespace here.\n\t\n\t\n\t// shim layer with setTimeout fallback\n\tvar requestAnimFrame = (function(){\n\t\treturn window.requestAnimationFrame ||\n\t\t\twindow.webkitRequestAnimationFrame ||\n\t\t\twindow.mozRequestAnimationFrame ||\n\t\t\twindow.oRequestAnimationFrame ||\n\t\t\twindow.msRequestAnimationFrame ||\n\t\t\tfunction(callback) {\n\t\t\t\twindow.setTimeout(callback, 1000 / 60);\n\t\t\t};\n\t})();\n\n\tfunction calculateScale(drawingHeight,maxSteps,minSteps,maxValue,minValue,labelTemplateString){\n\t\t\tvar graphMin,graphMax,graphRange,stepValue,numberOfSteps,valueRange,rangeOrderOfMagnitude,decimalNum;\n\t\t\t\n\t\t\tvalueRange = maxValue - minValue;\n\t\t\t\n\t\t\trangeOrderOfMagnitude = calculateOrderOfMagnitude(valueRange);\n\n        \tgraphMin = Math.floor(minValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);\n            \n            graphMax = Math.ceil(maxValue / (1 * Math.pow(10, rangeOrderOfMagnitude))) * Math.pow(10, rangeOrderOfMagnitude);\n            \n            graphRange = graphMax - graphMin;\n            \n            stepValue = Math.pow(10, rangeOrderOfMagnitude);\n            \n\t        numberOfSteps = Math.round(graphRange / stepValue);\n\t        \n\t        //Compare number of steps to the max and min for that size graph, and add in half steps if need be.\t        \n\t        while(numberOfSteps < minSteps || numberOfSteps > maxSteps) {\n\t        \tif (numberOfSteps < minSteps){\n\t\t\t        stepValue /= 2;\n\t\t\t        numberOfSteps = Math.round(graphRange/stepValue);\n\t\t        }\n\t\t        else{\n\t\t\t        stepValue *=2;\n\t\t\t        numberOfSteps = Math.round(graphRange/stepValue);\n\t\t        }\n\t        };\n\n\t        var labels = [];\n\t        populateLabels(labelTemplateString, labels, numberOfSteps, graphMin, stepValue);\n\t\t\n\t        return {\n\t\t        steps : numberOfSteps,\n\t\t\t\tstepValue : stepValue,\n\t\t\t\tgraphMin : graphMin,\n\t\t\t\tlabels : labels\t\t        \n\t\t        \n\t        }\n\t\t\n\t\t\tfunction calculateOrderOfMagnitude(val){\n\t\t\t  return Math.floor(Math.log(val) / Math.LN10);\n\t\t\t}\t\t\n\n\n\t}\n\n    //Populate an array of all the labels by interpolating the string.\n    function populateLabels(labelTemplateString, labels, numberOfSteps, graphMin, stepValue) {\n        if (labelTemplateString) {\n            //Fix floating point errors by setting to fixed the on the same decimal as the stepValue.\n            for (var i = 1; i < numberOfSteps + 1; i++) {\n                labels.push(tmpl(labelTemplateString, {value: (graphMin + (stepValue * i)).toFixed(getDecimalPlaces(stepValue))}));\n            }\n        }\n    }\n\t\n\t//Max value from array\n\tfunction Max( array ){\n\t\treturn Math.max.apply( Math, array );\n\t};\n\t//Min value from array\n\tfunction Min( array ){\n\t\treturn Math.min.apply( Math, array );\n\t};\n\t//Default if undefined\n\tfunction Default(userDeclared,valueIfFalse){\n\t\tif(!userDeclared){\n\t\t\treturn valueIfFalse;\n\t\t} else {\n\t\t\treturn userDeclared;\n\t\t}\n\t};\n\t//Is a number function\n\tfunction isNumber(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n\t}\n\t//Apply cap a value at a high or low number\n\tfunction CapValue(valueToCap, maxValue, minValue){\n\t\tif(isNumber(maxValue)) {\n\t\t\tif( valueToCap > maxValue ) {\n\t\t\t\treturn maxValue;\n\t\t\t}\n\t\t}\n\t\tif(isNumber(minValue)){\n\t\t\tif ( valueToCap < minValue ){\n\t\t\t\treturn minValue;\n\t\t\t}\n\t\t}\n\t\treturn valueToCap;\n\t}\n\tfunction getDecimalPlaces (num){\n\t\tvar numberOfDecimalPlaces;\n\t\tif (num%1!=0){\n\t\t\treturn num.toString().split(\".\")[1].length\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t} \n\t\n\tfunction mergeChartConfig(defaults,userDefined){\n\t\tvar returnObj = {};\n\t    for (var attrname in defaults) { returnObj[attrname] = defaults[attrname]; }\n\t    for (var attrname in userDefined) { returnObj[attrname] = userDefined[attrname]; }\n\t    return returnObj;\n\t}\n\t\n\t//Javascript micro templating by John Resig - source at http://ejohn.org/blog/javascript-micro-templating/\n\t  var cache = {};\n\t \n\t  function tmpl(str, data){\n\t    // Figure out if we're getting a template, or if we need to\n\t    // load the template - and be sure to cache the result.\n\t    var fn = !/\\W/.test(str) ?\n\t      cache[str] = cache[str] ||\n\t        tmpl(document.getElementById(str).innerHTML) :\n\t     \n\t      // Generate a reusable function that will serve as a template\n\t      // generator (and which will be cached).\n\t      new Function(\"obj\",\n\t        \"var p=[],print=function(){p.push.apply(p,arguments);};\" +\n\t       \n\t        // Introduce the data as local variables using with(){}\n\t        \"with(obj){p.push('\" +\n\t       \n\t        // Convert the template into pure JavaScript\n\t        str\n\t          .replace(/[\\r\\t\\n]/g, \" \")\n\t          .split(\"<%\").join(\"\\t\")\n\t          .replace(/((^|%>)[^\\t]*)'/g, \"$1\\r\")\n\t          .replace(/\\t=(.*?)%>/g, \"',$1,'\")\n\t          .split(\"\\t\").join(\"');\")\n\t          .split(\"%>\").join(\"p.push('\")\n\t          .split(\"\\r\").join(\"\\\\'\")\n\t      + \"');}return p.join('');\");\n\t   \n\t    // Provide some basic currying to the user\n\t    return data ? fn( data ) : fn;\n\t  };\n}\n\n\n"],"sourceRoot":"/source/"}